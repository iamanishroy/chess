import React, { useState, useEffect, useCallback } from "react";
import { useParams } from "react-router-dom";
import Chess from "chess.js";
import { useAuth } from "contexts/auth";
import setSecondUser, { presence } from "functions/user";
import checkId from "functions/checkId";
import { db } from "adapter";
import Board from "./board";
import Details from "./details";
// import Peer from "simple-peer";
// import WebRtcDataChannel from "webrtc-datachannel";
// import getUserMedia from "getusermedia";
// import Peer from "peerjs";

import DataChannel from "datachannel";
const game = new Chess();
var channel = new DataChannel();
// const rtc = new WebRtcDataChannel();
/*
TODO: change view on u2 (solved by {me})
TODO: timer -> 
TODO: on end(draw, winner)
TODO: on promotion // ui
TODO: don't update on own move
TODO: save matchId if not logged in 
*/

// const servers = {
//   iceServers: [
//     {
//       urls: ["stun:stun1.l.google.com:19302", "stun:stun2.l.google.com:19302"],
//     },
//   ],
//   iceCandidatePoolSize: 10,
// };

// Global State
// const pc = new RTCPeerConnection(servers);

const Playground = () => {
  const { currentUser } = useAuth();
  const [positions, setPositions] = useState(game.board());

  const { matchId } = useParams();
  const [matchIdChecked, setMatchIdChecked] = useState(false);
  const [match, setMatch] = useState(null);

  const [myTurn, setMyTurn] = useState(false);
  const [me, setMe] = useState(0);
  const [user1, setUser1] = useState(null);
  const [user2, setUser2] = useState(null);

  // const [connection, setConnection] = useState(null);
  /*
  console.log(connection);
  connection?.on("data", (data) => {
    console.log(data);
    // conn.send("hello!");
  });*/
  const subscribeToMatch = useCallback(() => {
    if (me) {
      db.ref("match/" + matchId).on("value", (snapshot) => {
        if (snapshot.val()) {
          // check if previous(own move) then don't change/ execute TODO:
          let newMatchData = snapshot.val();
          setUser1(newMatchData.u1);
          setUser2(newMatchData.u2);

          game.load(newMatchData.fen);
          setPositions(game.board());
          // check for over
          if (game.game_over()) {
            // draw
            // winner
            // repetition
            alert(
              `game over winner:- ${game.turn()} -> ${
                game.turn() === "w" ? "black" : "white"
              }`
            );
          }
          // set my turn
          setMyTurn(
            (me === 1 && game.turn() === "w") ||
              (me === 2 && game.turn() === "b")
          );
        }
      });
    }
  }, [matchId, me]);

  useEffect(() => {
    console.log("k");
    // const peerr = new Peer(currentUser.uid);
    // console.log(peerr);
    // peerr.on("connection", (conn) => {
    //   setConnection(conn);
    //   // console.log(conn);
    //   conn.on("data", (data) => {
    //     // Will print 'hi!'
    //     console.log(data);
    //     conn.send("hello!");
    //   });
    //   conn.on("open", () => {});
    // });

    checkId(matchId).then(async (res) => {
      if (res) {
        if (res.u1.u === currentUser.uid) {
          // already in match its just a refresh
          // set first user as own
          setMe(1);
          // set second user as another
          setUser1(res.u1);
          // if second user available then add u2 also
          if (res.u2) {
            setUser2(res.u2);
          } else {
            // wait to join
          }

          setMatch(res.matchId);
          game.load(res.fen);
          setPositions(game.board());
          // subscribe to change
          subscribeToMatch(res.matchId);
          presence(res.matchId, "u1");

          channel.open(matchId);

          channel.onopen = function (userid) {
            console.log(userid);
          };

          // const request = await rtc.initiateConnect();
          // console.log(request);
          // db.ref("match/" + matchId + "/u1").update({
          //   signal: request,
          // });
          // // Transfer the `request` to recipient via signaller (for example web-server or qr code)
          // // const answer = await getAnswer(request);
          // // Then pass an `answer` here
          // await rtc.setAnswer("answer");

          // // Connection is opened!

          // const response = await rtc.send({ question: "How are you?" });
          // console.log(response);

          /*
          getUserMedia({ video: true, audio: false }, function (err, stream) {
            if (err) {
              console.error(err);
            }*/

          // const peer = new Peer({
          //   initiator: true,
          //   trickle: false,
          //   // stream: stream,
          // });
          // // console.log("oo");

          // peer.on("signal", (data) => {
          //   console.log(data);
          //   db.ref("match/" + matchId + "/u1").update({
          //     signal: JSON.stringify(data),
          //   });
          // });

          // console.log(res?.u2?.signal);
          // peer.signal(res?.u2?.signal);

          // peer.on("data", (data) => {
          //   // got a data channel message
          //   console.log("got a message from peer1: " + data);
          // });
          // peer.on("connect", () => {
          //   // wait for 'connect' event before using the data channel
          //   console.log("hey peer2, how is it going?");
          // });
          /*
          });*/
        } else if (res.u2?.u === currentUser.uid) {
          // already in match its just a refresh
          // set first user as another
          setMe(2);
          setUser1(res.u1);
          setUser2(res.u2);
          // set second user as own
          setMatch(res.matchId);
          // console.log(res.fen);
          game.load(res.fen);
          setPositions(game.board());
          // subscribe to change
          subscribeToMatch(res.matchId);
          presence(res.matchId, "u2");

          // const answer = await rtc.initByRequest(res.u1.signal);

          await rtc.channelOpened();

          // Connection is opened!

          // We can listen for messages or send messages here
          rtc.on("message", async (message) => {
            if (message.question === "How are you?") {
              rtc.send({ answer: "I am fine." });
            }
          });
          // const conn = peerr.connect(res.u1.u);
          // setConnection(conn);

          // conn.on("open", () => {
          //   conn.send("hi2!");
          // });

          /*getUserMedia({ video: true, audio: false }, function (err, stream) {
            if (err) {
              console.error(err);
            }*/
          // const peer = new Peer({
          //   initiator: false,
          //   trickle: false,
          //   // stream: stream,
          // });
          // peer.signal(JSON.parse(res.u1?.signal));
          // // console.log("oo");
          // console.log(res.u1.signal);
          // // peer.signal(res.u1?.signal);

          // // console.log(peer.signal(res.u1.signal));
          // peer.on("signal", (data) => {
          //   console.log(data);
          //   db.ref("match/" + matchId + "/u2")
          //     .update({ signal: data })
          //     .then(() => {
          //       console.log(res.u1.signal);
          //       // peer.send("hi");
          //     });
          // });

          // peer.on("connect", () => {
          //   console.log("connected");
          // });
          // peer.on("signal", (data) => {
          // db.
          //   console.log(data)
          // });

          /*
          });*/
        } else {
          if (res.u2) {
            // match already started
            alert("already started");
            // exit
          } else {
            // register 2
            setSecondUser(res.matchId, currentUser);
            setMe(2);
            setUser1(res.u1);
            setUser2({
              n: currentUser.displayName,
              o: "online",
              p: currentUser.photoURL,
              u: currentUser.uid,
            });
            // set first user as another
            // set second user as own
            setMatch(res.matchId);
            game.load(res.fen);
            setPositions(game.board());
            // subscribe to change
            subscribeToMatch(res.matchId);
            presence(res.matchId, "u2");

            // const conn = peerr.connect(res.u1.u);
            // setConnection(conn);

            // conn.on("open", () => {
            //   conn.send("hi3!");
            // });

            /*getUserMedia({ video: true, audio: false }, function (err, stream) {
              if (err) {
                console.error(err);
              }*/
            // const peer = new Peer({
            //   initiator: false,
            //   trickle: false,
            //   // stream: stream,
            // });
            // console.log("oo");
            // console.log(res.u1.signal);
            // peer.signal(JSON.parse(res.u1?.signal));
            // // peer.on("signal", (data) => console.log(data));
            // peer.on("signal", (data) => {
            //   console.log(data);
            //   db.ref("match/" + matchId + "/u2")
            //     .update({ signal: data })
            //     .then(() => {
            //       console.log(res.u1.signal);
            //       // peer.send("hi");
            //     });
            // });
            /*
              // peer.on("signal", (data) => {
              //   console.log(data);
              //   db.ref("match/" + matchId + "/u2").update({ signal: data });
              // });
            });*/
          }
        }
      } else {
        console.log("No game");
      }
      setMatchIdChecked(true);
    });
  }, [matchId, currentUser, subscribeToMatch]);

  return (
    <>
      {matchIdChecked ? (
        match ? (
          <div className="playground">
            <div className="left">
              {/* <button
                onClick={() => {
                  console.log("5");
                  connection.send("789");
                }}
              >
                send
              </button> */}
              <Details user1={user1} user2={user2} />
            </div>
            <div className="right">
              <Board
                game={game}
                matchIdChecked={matchIdChecked}
                match={match}
                positions={positions}
                setPositions={setPositions}
                myTurn={myTurn}
                me={me}
              />
            </div>
          </div>
        ) : (
          <>No Match</>
        )
      ) : (
        <>checking ID</>
      )}
    </>
  );
};

export default Playground;
